ANSI-Cコンパイラの lcc 4.2 をwin32用についてちょっと修正したモノです。

元の README, CPYRIGHT の適当訳の README.jp, CPYRIGHT.jp を用意したので、
それらも参照してください。


lcc は

	lcc, A Retargetable Compiler for ANSI C
	https://sites.google.com/site/lccretargetablecompiler/

で配布されてるANSI-Cコンパイラで、設計＆実装を解説した書籍もでているよう
です。というか書籍のサンプル/教材としての側面が強そうに思えます。
（実用品なら作りこむべきところを簡易(単純)なままにしているし）

ライセンスを見ての通りわりと緩めだったり古くからソース公開されてたり
するためか、 lcc 派生(フリー＆商用)コンパイラの lcc-win32 や Pelles-C 
が出ていたりします。

lcc-winやPelles-C は結構作り込まれていますが、もともとの lcc 自体はすごく
pure な ansi-c89 コンパイラのままです。c99のごく一部 //コメントと long long
は追加されていますが、long long は x86用だと 32ビット整数(alpha用は64bit)
だし、他は inline さえ無い状態です。

lcc自体は リンカやライブラリアン、標準ライブラリを提供しておらず、それらは
既存のものを流用しており、コンパイラドライバではそれらをソースに直書きして
います。unix系の場合はos標準搭載のcコンパイラに寄生で もとより構成がある
程度決まってるので問題少なそうですが、win用はvc(5)だけで、今使おうとすると
手直しが必要...

で、Winではコンパイラ/ヴァージョンごとフォルダ構成・設定オプションの幅が
あるのでソース直書でなく定義ファイルを読み込むように修正してみました。

寄生対象として、vc7.1〜VC11、borland-c (5.5.1+tasm32|jwasm) が可能です.
  ※ lcc自体のコンパイルは各種 Cコンパイラで可能ですが、lccが生成する
     アセンブラソースや C ABI の都合、寄生対象は msvc 互換の必要あり.

dll(import/export)未対応なので vc の Express版は不可。
一応無料ツールのみとしては bcc32 5.5.1 と JWasm の組み合わせで動きます。

できた lcc で何かをコンパイルする時、新し目のVCだとヘッダでinlineや拡張で
通らないことがあります。vc7.1 や bcc 5.5.1 のような古めのコンパイラの
ほうが無難そうです。

※ ヘッダ寄生の辻褄合わせはたいてい #define マクロ定義で行いますが、
  long long については たとえ32bitでも認識してくれないと long long を
  使った宣言のエラー回避できないので必須だったのだな、と納得でした。


lccのコンパイル:

・使用するコンパイラのパスを確認しておき、mk.bat 中の対応するコンパイラ
  の set COMPILERDIR= のパスを必要に応じて修正

・dos窓(コマンドライン)で コンパイラ（必要なら jwasm も) のパスを設定する.

・ mk.bat コンパイラ名
  でコンパイル。
  指定するコンパイラ名は
      vc71,vc8,vc9,vc10,vc11 (ml使用)
      bcc      (bcc32 5.5.1 + tasm32 使用の場合)
      bccJwasm (bcc32 5.5.1 + jwasm 使用の場合)
  のいづれか. (vc10は未確認)

・とりあえず、vc9 を例として
      mk.bat vc9
  をすると
      bin_vc9\         vc9 で生成した lcc 一式
      bin_vc9_self1\   bin_vc9\ の lcc でコンパイルした lcc一式
      bin_vc9_self2\   bin_vc9_self1\ のlccでコンパイルした lcc一式
      bld_vc9\         作業フォルダ
      bld_vc9_self1\   作業フォルダ
      bld_vc9_self2\   作業フォルダ
  が作られ、最後に
    fc /b bin_vc9_self1\lcc.exe bin_vc9_self2\lcc.exe
  を行い、バイナリ差分を表示します。
  理想的には0バイトですが、どうも数バイト違いが（日付かゴミか何か)
  でることが多いです。1〜4バイトくらいの差の場合は意図どおりと思われます。
  あとは お好みの lcc.exe のある bin_vc7?????? フォルダを bin に rename して
  他の bin???やbld???フォルダは削除してください。

・mk.bat vc9 simple
  とすれば、コンパイラ名をつけないフォルダ
    bin\ bin_self1\ bin_self2\ bld\ bld_self1\ bld_self2\
  で生成します。

・テストは lcc\bin のパスを通した状態で
  tst.bat
  を実行. 比較元が vc5 で作られたソースなので vc71〜vc11 では微妙に変化
  あり、で差分が多量に出る場合もあります（vcの結果をチラ見する限りラベル
  番号が変わった等で実質あまりかわってない印象ですが詳細未確認)
  ※ tst/struct.c はコンパイルが通らず微修正した影響でasmソースも変わった
    ため、これのみ vc71 での結果に差し替えています。
  bcc でコンパイルした場合は、ライブラリの関数が違ったりパス区切りが
  /でなく\なので余計に差分が出力されます。


ソース変更について:

- makefile.nt を破棄し、代わりに mk.bat, tst.bat を用意.

- 未初期化変数の初期化や警告修正等.
  (己のソース修正部分は/*@@@ とかでマーク)
  
- ソース中に直書きされていたリンカーやヘッダ・パスやオプション設定 を
  lcc.exe と同じ フォルダにある lcc.cfg ファイルから読み込むように変更.
  (lcc1.exe なら lcc1.cfg を読み込む)

- lcc.cfg の中で、元々 $1,$2,$3 という変数が用意されていましたが、
  lcc.exe のあるディレクトリを表す $0 という変数を追加しました。

- lcc.exe (とcpp.exe) に 暗黙にincludeするファイルを指定する -i を追加.

- 寄生先コンパイラ別に include/x86/win32/_lcc_with_???.h というヘッダ
  ファイルを用意し、そこで寄生先コンパイラのヘッダ等の辻褄合わせ。
  lcc.cfg の設定で -i して(暗黙に)読み込む。
  ※ __declspecやinline等未対応の機能を空化マクロで対処.

- bar.c に #include "../baz.h" があるとき、bar.c のあるフォルダからの
  相対でなく、カレントディレクトリからの相対になって読み込めないことが
  あったのを、bar.c からの相対で読み込めるように修正.

- Cプリプロセッサで無限ループに陥ることがあるので、強制ループ抜けして
   対処。

- tst/struct.c がコンパイルできなかったので微修正.
  それにあわせて、x86/win32/tst/struct.sbk
  を vc71 で作った lcc のコンパイル結果 struct.s を元に修正

- それ以外の linux/unix 用とかのチェックをしていないのでそちら向けで
  エンバグになってないか不明。

- シフトJIS 未対応。
  \含有全角をソース中やソースファイル名に使うと不具合有。


念のため:
- ライセンス等は当然元のまま。
  己の作業は透過的に扱ってください。当然無保証無責任。
- する人はいないと思うけれど COPYRIGHT にあるように、この改変版についての
  問い合わせは元作者にはしないようにお願いします。

Masashi Kitamura (tenka@6809.net)
 